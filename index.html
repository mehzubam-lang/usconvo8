<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>US CONVO - Fixed Version</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

body {
  background: linear-gradient(135deg, #9b7fb5 0%, #d4a5d4 50%, #c8b3e6 100%);
  color: white;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  min-height: 100vh;
  padding: 20px;
  -webkit-touch-callout: none;
}

body {
  pointer-events: auto;
}

.hidden {
  display: none !important;
}

.container {
  max-width: 700px;
  margin: 0 auto;
}

.box {
  background: rgba(155, 127, 181, 0.85);
  backdrop-filter: blur(10px);
  padding: 30px;
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(139, 69, 139, 0.4);
  border: 2px solid rgba(218, 165, 218, 0.5);
}

h2 {
  text-align: center;
  color: white;
  margin-bottom: 25px;
  font-size: 28px;
  text-shadow: 0 2px 8px rgba(139, 69, 139, 0.6);
  font-weight: 600;
}

.label {
  color: white;
  font-size: 14px;
  margin-bottom: 8px;
  font-weight: 500;
}

input[type="text"],
input[type="file"] {
  width: 100%;
  padding: 14px;
  margin-bottom: 15px;
  border-radius: 10px;
  font-size: 16px;
  border: 2px solid #daa5da;
  background: rgba(212, 165, 212, 0.3);
  color: white;
  transition: all 0.3s ease;
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
}

input[type="text"]::placeholder {
  color: rgba(255, 255, 255, 0.6);
}

input[type="text"]:focus {
  outline: none;
  border-color: white;
  background: rgba(212, 165, 212, 0.4);
  box-shadow: 0 0 15px rgba(218, 165, 218, 0.5);
}

button {
  width: 100%;
  padding: 14px;
  border-radius: 10px;
  font-size: 16px;
  border: none;
  background: linear-gradient(135deg, #ab7bab 0%, #8b458b 100%);
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  margin-bottom: 10px;
  box-shadow: 0 4px 12px rgba(139, 69, 139, 0.3);
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(139, 69, 139, 0.5);
  background: linear-gradient(135deg, #b98bb9 0%, #9b5a9b 100%);
}

button:active {
  transform: translateY(0);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.link-box {
  background: rgba(200, 179, 230, 0.3);
  padding: 20px;
  border-radius: 10px;
  border: 2px dashed rgba(218, 165, 218, 0.8);
  margin-bottom: 20px;
}

.link-box b {
  color: white;
  display: block;
  margin-bottom: 15px;
  font-size: 16px;
  text-align: center;
}

#room-link {
  background: rgba(155, 127, 181, 0.5);
  padding: 15px;
  border-radius: 8px;
  word-break: break-all;
  font-family: monospace;
  font-size: 13px;
  color: white;
  margin-bottom: 15px;
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  text-align: center;
}

#timer {
  color: white;
  font-weight: bold;
  text-align: center;
  padding: 10px;
  font-size: 15px;
  background: rgba(171, 123, 171, 0.4);
  border-radius: 8px;
  margin-bottom: 15px;
}

#status {
  text-align: center;
  padding: 10px;
  border-radius: 8px;
  margin-bottom: 15px;
  font-weight: 500;
  font-size: 14px;
}

#status.connecting {
  background: rgba(212, 165, 212, 0.3);
  color: white;
}

#status.connected {
  background: rgba(171, 123, 171, 0.4);
  color: white;
}

#status.error {
  background: rgba(139, 69, 139, 0.4);
  color: white;
}

.call-controls {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

.call-controls button {
  flex: 1;
  padding: 12px;
  font-size: 14px;
  margin-bottom: 0;
}

.call-btn-audio {
  background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
}

.call-btn-video {
  background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
}

.call-btn-end {
  background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
}

.video-container {
  position: relative;
  margin-bottom: 15px;
  border-radius: 10px;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.5);
  display: none;
}

.video-container.active {
  display: block;
}

#remote-video {
  width: 100%;
  height: auto;
  display: block;
  max-height: 400px;
  object-fit: cover;
}

#local-video {
  position: absolute;
  bottom: 10px;
  right: 10px;
  width: 120px;
  height: auto;
  border-radius: 8px;
  border: 2px solid white;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  object-fit: cover;
}

.call-status {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(139, 69, 139, 0.9);
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 14px;
  font-weight: bold;
  color: white;
}

.call-timer {
  position: absolute;
  top: 10px;
  right: 10px;
  background: rgba(139, 69, 139, 0.9);
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 14px;
  font-weight: bold;
  color: white;
}

.incoming-call-modal {
  display: none;
  position: fixed;
  z-index: 2000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(75, 46, 92, 0.95);
  align-items: center;
  justify-content: center;
}

.incoming-call-modal.show {
  display: flex;
}

.incoming-call-content {
  background: rgba(155, 127, 181, 0.95);
  padding: 40px;
  border-radius: 20px;
  text-align: center;
  max-width: 400px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
}

.incoming-call-content h3 {
  font-size: 24px;
  margin-bottom: 15px;
  color: white;
}

.incoming-call-content p {
  font-size: 18px;
  margin-bottom: 25px;
  color: white;
}

.incoming-call-buttons {
  display: flex;
  gap: 10px;
}

.incoming-call-buttons button {
  flex: 1;
  margin-bottom: 0;
}

.accept-call {
  background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
}

.reject-call {
  background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
}

#messages {
  height: 400px;
  overflow-y: auto;
  border: 2px solid rgba(218, 165, 218, 0.6);
  padding: 15px;
  background: rgba(155, 127, 181, 0.3);
  margin-bottom: 15px;
  border-radius: 10px;
  scroll-behavior: smooth;
}

#messages::-webkit-scrollbar {
  width: 8px;
}

#messages::-webkit-scrollbar-track {
  background: rgba(155, 127, 181, 0.2);
  border-radius: 10px;
}

#messages::-webkit-scrollbar-thumb {
  background: rgba(139, 69, 139, 0.6);
  border-radius: 10px;
}

#messages::-webkit-scrollbar-thumb:hover {
  background: rgba(139, 69, 139, 0.8);
}

.message-wrapper {
  display: flex;
  align-items: flex-start;
  margin: 10px 0;
  animation: slideIn 0.3s ease;
}

.message-wrapper.sent {
  flex-direction: row-reverse;
}

.profile-emoji-circle {
  width: 36px;
  height: 36px;
  min-width: 36px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  margin: 0 8px;
  background: rgba(200, 179, 230, 0.4);
  border: 2px solid rgba(218, 165, 218, 0.6);
}

.message-wrapper.sent .profile-emoji-circle {
  background: rgba(171, 123, 171, 0.5);
  border-color: rgba(139, 69, 139, 0.6);
}

.message {
  padding: 12px 15px;
  border-radius: 12px;
  max-width: 65%;
  word-wrap: break-word;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message.sent {
  background: linear-gradient(135deg, #c8b3e6 0%, #daa5da 100%);
  color: #4a2e5c;
  box-shadow: 0 2px 8px rgba(139, 69, 139, 0.2);
}

.message.received {
  background: linear-gradient(135deg, #ab7bab 0%, #9b7fb5 100%);
  color: white;
  box-shadow: 0 2px 8px rgba(139, 69, 139, 0.2);
}

.message .username {
  font-weight: bold;
  margin-bottom: 4px;
  font-size: 13px;
  opacity: 1;
}

.message.sent .username {
  color: #4a2e5c;
}

.message.received .username {
  color: white;
}

.message .text {
  font-size: 15px;
  line-height: 1.4;
}

.message img {
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  margin-top: 8px;
  display: block;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.system-message {
  color: white;
  text-align: center;
  font-style: italic;
  padding: 8px;
  margin: 8px 0;
  font-size: 14px;
  opacity: 0.9;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.emoji-picker {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  margin-bottom: 15px;
  padding: 10px;
  background: rgba(200, 179, 230, 0.3);
  border-radius: 10px;
}

.emoji-picker span {
  font-size: 26px;
  cursor: pointer;
  transition: transform 0.2s ease;
  user-select: none;
}

.emoji-picker span:hover {
  transform: scale(1.3);
}

.emoji-picker span:active {
  transform: scale(1.1);
}

#file-input {
  display: none;
}

.file-button {
  background: linear-gradient(135deg, #9b7fb5 0%, #8b458b 100%);
  color: white;
}

.file-button:hover {
  background: linear-gradient(135deg, #ab8fc5 0%, #9b5a9b 100%);
}

.input-group {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
}

.input-group input {
  flex: 1;
  margin-bottom: 0;
}

.input-group button {
  width: auto;
  padding: 14px 25px;
  margin-bottom: 0;
}

.image-modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(75, 46, 92, 0.95);
  align-items: center;
  justify-content: center;
}

.image-modal.show {
  display: flex;
}

.image-modal img {
  max-width: 90%;
  max-height: 90%;
  object-fit: contain;
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
}

.image-modal .close {
  position: absolute;
  top: 20px;
  right: 35px;
  color: white;
  font-size: 40px;
  font-weight: bold;
  cursor: pointer;
  text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
  transition: transform 0.2s ease;
}

.image-modal .close:hover {
  transform: scale(1.2);
}

.screenshot-warning {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(139, 69, 139, 0.98);
  z-index: 10000;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  animation: fadeIn 0.3s ease;
}

.screenshot-warning.show {
  display: flex;
}

.screenshot-warning-content {
  text-align: center;
  padding: 40px;
  background: rgba(155, 127, 181, 0.9);
  border-radius: 20px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  max-width: 500px;
}

.screenshot-warning h2 {
  font-size: 48px;
  margin-bottom: 20px;
}

.screenshot-warning p {
  font-size: 24px;
  font-weight: 600;
  color: white;
  margin-bottom: 10px;
}

.screenshot-warning .subtext {
  font-size: 16px;
  opacity: 0.9;
  margin-top: 15px;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.blurred {
  filter: blur(20px);
  pointer-events: none;
  transition: filter 0.3s ease;
}

.gender-tabs {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
}

.gender-tab {
  flex: 1;
  padding: 12px;
  background: rgba(200, 179, 230, 0.3);
  border: 2px solid rgba(218, 165, 218, 0.5);
  margin-bottom: 0;
}

.gender-tab.active {
  background: linear-gradient(135deg, #ab7bab 0%, #8b458b 100%);
  border-color: white;
}

.emoji-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 10px;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(200, 179, 230, 0.3);
  border-radius: 10px;
}

.emoji-option {
  font-size: 40px;
  padding: 15px;
  text-align: center;
  cursor: pointer;
  border-radius: 8px;
  transition: all 0.2s ease;
  background: rgba(155, 127, 181, 0.3);
  border: 2px solid transparent;
}

.emoji-option:hover {
  transform: scale(1.1);
  background: rgba(171, 123, 171, 0.5);
  border-color: rgba(218, 165, 218, 0.8);
}

.emoji-option.selected {
  background: rgba(171, 123, 171, 0.6);
  border-color: white;
  box-shadow: 0 4px 12px rgba(139, 69, 139, 0.4);
}

.selected-profile {
  margin-bottom: 20px;
}

.profile-preview {
  background: rgba(200, 179, 230, 0.3);
  padding: 20px;
  border-radius: 10px;
  text-align: center;
}

.profile-emoji {
  font-size: 60px;
  display: block;
  margin-bottom: 10px;
}

.preview-name {
  font-size: 18px;
  font-weight: bold;
  color: white;
}

.debug-info {
  background: rgba(0, 0, 0, 0.3);
  padding: 10px;
  border-radius: 8px;
  margin-bottom: 15px;
  font-size: 12px;
  font-family: monospace;
  color: #ccc;
}

.waiting-message {
  text-align: center;
  padding: 20px;
  background: rgba(200, 179, 230, 0.3);
  border-radius: 10px;
  margin-bottom: 20px;
}

.waiting-message h3 {
  font-size: 20px;
  margin-bottom: 10px;
  color: white;
}

.waiting-message p {
  font-size: 15px;
  color: rgba(255, 255, 255, 0.9);
}

.progress-bar {
  background: rgba(200, 179, 230, 0.3);
  border-radius: 10px;
  padding: 10px;
  margin-bottom: 15px;
}

.progress-fill {
  background: linear-gradient(135deg, #ab7bab 0%, #8b458b 100%);
  height: 8px;
  border-radius: 4px;
  transition: width 0.3s ease;
}

.progress-text {
  text-align: center;
  margin-top: 8px;
  font-size: 13px;
  color: white;
}

@media (max-width: 600px) {
  .box {
    padding: 20px;
  }
  
  .message {
    max-width: 70%;
  }
  
  h2 {
    font-size: 24px;
  }
  
  .emoji-grid {
    grid-template-columns: repeat(3, 1fr);
  }
  
  #local-video {
    width: 80px;
  }
  
  .profile-emoji-circle {
    width: 32px;
    height: 32px;
    min-width: 32px;
    font-size: 18px;
  }
}
</style>
</head>
<body>

<div class="container" id="main-content">
  <!-- PAGE 1: Profile Setup Screen -->
  <div class="box" id="profile-screen">
    <h2>üíó US CONVO üíó</h2>
    <div class="label">Enter your name</div>
    <input id="username-input" type="text" placeholder="Your name" maxlength="20">
    
    <div class="label" style="margin-top: 20px;">Choose your profile emoji</div>
    
    <div class="gender-tabs">
      <button type="button" class="gender-tab active" onclick="showEmojiGender('boy')">üë¶ Boy</button>
      <button type="button" class="gender-tab" onclick="showEmojiGender('girl')">üëß Girl</button>
    </div>
    
    <div class="emoji-grid" id="boy-emojis">
      <div class="emoji-option selected" onclick="selectProfileEmoji('üë¶')">üë¶</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üßë')">üßë</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üòé')">üòé</div>
      <div class="emoji-option" onclick="selectProfileEmoji('ü§†')">ü§†</div>
      <div class="emoji-option" onclick="selectProfileEmoji('ü•∑')">ü•∑</div>
      <div class="emoji-option" onclick="selectProfileEmoji('ü¶∏‚Äç‚ôÇÔ∏è')">ü¶∏‚Äç‚ôÇÔ∏è</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üßô‚Äç‚ôÇÔ∏è')">üßô‚Äç‚ôÇÔ∏è</div>
      <div class="emoji-option" onclick="selectProfileEmoji('ü§¥')">ü§¥</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üë®‚ÄçüöÄ')">üë®‚ÄçüöÄ</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üßë‚Äçüíª')">üßë‚Äçüíª</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üï∫')">üï∫</div>
      <div class="emoji-option" onclick="selectProfileEmoji('ü§µ')">ü§µ</div>
    </div>
    
    <div class="emoji-grid hidden" id="girl-emojis">
      <div class="emoji-option" onclick="selectProfileEmoji('üëß')">üëß</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üë©')">üë©</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üòä')">üòä</div>
      <div class="emoji-option" onclick="selectProfileEmoji('ü•∞')">ü•∞</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üå∏')">üå∏</div>
      <div class="emoji-option" onclick="selectProfileEmoji('ü¶∏‚Äç‚ôÄÔ∏è')">ü¶∏‚Äç‚ôÄÔ∏è</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üßö‚Äç‚ôÄÔ∏è')">üßö‚Äç‚ôÄÔ∏è</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üë∏')">üë∏</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üë©‚ÄçüöÄ')">üë©‚ÄçüöÄ</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üíÉ')">üíÉ</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üë∞')">üë∞</div>
      <div class="emoji-option" onclick="selectProfileEmoji('üéÄ')">üéÄ</div>
    </div>
    
    <div class="selected-profile">
      <div class="label">Selected Profile:</div>
      <div class="profile-preview">
        <span id="selected-emoji" class="profile-emoji">üë¶</span>
        <span id="preview-name" class="preview-name">Your name</span>
      </div>
    </div>
    
    <button onclick="initializeChat()">Continue</button>
  </div>

  <!-- PAGE 2: Link Share Screen (for host only) -->
  <div class="box hidden" id="link-screen">
    <h2>üìã Share Room Link</h2>
    
    <div class="debug-info" id="debug-info-link">
      Creating room...
    </div>
    
    <div class="selected-profile">
      <div class="profile-preview">
        <span id="link-page-emoji" class="profile-emoji">üë¶</span>
        <span id="link-page-name" class="preview-name">Your name</span>
      </div>
    </div>
    
    <div class="link-box">
      <b>üìã Share this link with your friend</b>
      <div id="room-link">Generating link...</div>
      <div id="timer">Link expires in 20 minutes after copying</div>
      <button onclick="copyRoomLink()">üìã Copy Link</button>
    </div>

    <div class="waiting-message">
      <h3>‚è≥ Waiting for friend to join...</h3>
      <p>Once your friend joins, you'll be redirected to the chat</p>
    </div>

    <div id="status-link" class="connecting">Initializing room...</div>
  </div>

  <!-- PAGE 3: Chat Screen -->
  <div class="box hidden" id="chat-screen">
    <h2>üí¨ Chat Room</h2>
    
    <div class="debug-info" id="debug-info">
      Status: Initializing...
    </div>

    <div id="status" class="connecting">Connecting...</div>

    <!-- Video Container -->
    <div class="video-container" id="video-container">
      <video id="remote-video" autoplay playsinline></video>
      <video id="local-video" autoplay playsinline muted></video>
      <div class="call-status" id="call-status">Connecting...</div>
      <div class="call-timer" id="call-timer">00:00</div>
    </div>

    <!-- Call Controls -->
    <div class="call-controls" id="call-controls">
      <button class="call-btn-audio" onclick="startAudioCall()">üìû Audio Call</button>
      <button class="call-btn-video" onclick="startVideoCall()">üìπ Video Call</button>
    </div>
    <button class="call-btn-end hidden" id="end-call-btn" onclick="endCall()">üî¥ End Call</button>

    <div id="messages"></div>

    <div class="emoji-picker">
      <span onclick="insertEmoji('üíó')">üíó</span>
      <span onclick="insertEmoji('üíñ')">üíñ</span>
      <span onclick="insertEmoji('üíï')">üíï</span>
      <span onclick="insertEmoji('üíì')">üíì</span>
      <span onclick="insertEmoji('üíû')">üíû</span>
      <span onclick="insertEmoji('üíò')">üíò</span>
      <span onclick="insertEmoji('ü©∑')">ü©∑</span>
      <span onclick="insertEmoji('üéÄ')">üéÄ</span>
      <span onclick="insertEmoji('üå∏')">üå∏</span>
      <span onclick="insertEmoji('‚ù§Ô∏è‚Äçüî•')">‚ù§Ô∏è‚Äçüî•</span>
    </div>

    <div class="input-group">
      <input id="message-input" type="text" placeholder="Type your message..." maxlength="500">
      <button onclick="sendMessage()">Send</button>
    </div>

    <input type="file" id="file-input" accept="image/*">
    <button class="file-button" onclick="selectImage()">üì∑ Send Image</button>
  </div>
</div>

<!-- Incoming Call Modal -->
<div id="incoming-call-modal" class="incoming-call-modal">
  <div class="incoming-call-content">
    <h3 id="incoming-call-type">üìû Incoming Call</h3>
    <p id="incoming-caller-name">Friend is calling...</p>
    <div class="incoming-call-buttons">
      <button class="accept-call" onclick="acceptIncomingCall()">‚úÖ Accept</button>
      <button class="reject-call" onclick="rejectIncomingCall()">‚ùå Reject</button>
    </div>
  </div>
</div>

<div id="screenshot-warning" class="screenshot-warning">
  <div class="screenshot-warning-content">
    <h2>üö´</h2>
    <p>Screenshots are not allowed</p>
    <p class="subtext">This is a private conversation</p>
  </div>
</div>

<div id="image-modal" class="image-modal" onclick="closeImageModal()">
  <span class="close">&times;</span>
  <img id="modal-image" src="" alt="Full size image">
</div>

<script>
// Global state
const state = {
  peer: null,
  connection: null,
  username: '',
  profileEmoji: 'üë¶',
  friendProfileEmoji: '',
  roomId: '',
  myPeerId: '',
  isHost: false,
  isConnected: false,
  linkExpired: false,
  linkCopied: false,
  timerInterval: null,
  reconnectAttempts: 0,
  maxReconnectAttempts: 5,
  peerReady: false,
  connectionAttempts: 0,
  maxConnectionAttempts: 5,
  connectionTimeout: null,
  peerOpenPromise: null,
  
  // Call state
  localStream: null,
  remoteStream: null,
  currentCall: null,
  inCall: false,
  callType: null,
  callStartTime: null,
  callTimerInterval: null,
  incomingCall: null,
  
  // Data channel state
  messageQueue: [],
  dataChannelReady: false,
  chunkSize: 16000, // Smaller chunks for better reliability
  pendingChunks: new Map()
};

// IMPROVED: Multiple STUN/TURN servers with better configuration
const iceConfig = {
  iceServers: [
    // Google STUN servers
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    { urls: 'stun:stun3.l.google.com:19302' },
    { urls: 'stun:stun4.l.google.com:19302' },
    
    // Additional STUN servers for redundancy
    { urls: 'stun:stun.stunprotocol.org:3478' },
    { urls: 'stun:stun.voip.blackberry.com:3478' },
    { urls: 'stun:stun.voipbuster.com:3478' },
    { urls: 'stun:stun.voipstunt.com:3478' },
    { urls: 'stun:stun.voxgratia.org:3478' },
    
    // OpenRelay free TURN server (consider using your own TURN server for production)
    {
      urls: 'turn:openrelay.metered.ca:80',
      username: 'openrelayproject',
      credential: 'openrelayproject'
    },
    {
      urls: 'turn:openrelay.metered.ca:443',
      username: 'openrelayproject',
      credential: 'openrelayproject'
    },
    {
      urls: 'turn:openrelay.metered.ca:443?transport=tcp',
      username: 'openrelayproject',
      credential: 'openrelayproject'
    }
  ],
  iceCandidatePoolSize: 10,
  iceTransportPolicy: 'all',
  bundlePolicy: 'max-bundle',
  rtcpMuxPolicy: 'require'
};

// Debug logging
function debugLog(message, data = null) {
  const timestamp = new Date().toLocaleTimeString();
  console.log(`[${timestamp}] ${message}`, data || '');
  const debugInfo = document.getElementById('debug-info');
  const debugInfoLink = document.getElementById('debug-info-link');
  if (debugInfo) {
    debugInfo.textContent = `[${timestamp}] ${message}`;
  }
  if (debugInfoLink) {
    debugInfoLink.textContent = `[${timestamp}] ${message}`;
  }
}

// Profile emoji selection
let selectedProfileEmoji = 'üë¶';

function showEmojiGender(gender) {
  const boyTab = document.querySelector('.gender-tab:first-child');
  const girlTab = document.querySelector('.gender-tab:last-child');
  const boyEmojis = document.getElementById('boy-emojis');
  const girlEmojis = document.getElementById('girl-emojis');
  
  if (gender === 'boy') {
    boyTab.classList.add('active');
    girlTab.classList.remove('active');
    boyEmojis.classList.remove('hidden');
    girlEmojis.classList.add('hidden');
  } else {
    girlTab.classList.add('active');
    boyTab.classList.remove('active');
    girlEmojis.classList.remove('hidden');
    boyEmojis.classList.add('hidden');
  }
}

function selectProfileEmoji(emoji) {
  selectedProfileEmoji = emoji;
  
  document.querySelectorAll('.emoji-option').forEach(el => {
    el.classList.remove('selected');
  });
  
  event.target.classList.add('selected');
  
  document.getElementById('selected-emoji').textContent = emoji;
  
  const username = document.getElementById('username-input').value.trim() || 'Your name';
  document.getElementById('preview-name').textContent = username;
}

// Screenshot detection
(function() {
  let screenshotWarningTimeout;
  
  function showScreenshotWarning() {
    const warning = document.getElementById('screenshot-warning');
    warning.classList.add('show');
    clearTimeout(screenshotWarningTimeout);
    screenshotWarningTimeout = setTimeout(() => {
      warning.classList.remove('show');
    }, 3000);
  }
  
  document.addEventListener('keyup', function(e) {
    if (e.key === 'PrintScreen') {
      showScreenshotWarning();
      navigator.clipboard.writeText('');
    }
  });
  
  document.addEventListener('keydown', function(e) {
    if (
      (e.key === 'PrintScreen') ||
      (e.metaKey && e.shiftKey && (e.key === '3' || e.key === '4' || e.key === '5')) ||
      (e.metaKey && e.shiftKey && e.key === 's') ||
      (e.key === 's' && e.shiftKey && e.metaKey)
    ) {
      e.preventDefault();
      showScreenshotWarning();
      return false;
    }
  });
  
  document.addEventListener('visibilitychange', function() {
    const mainContent = document.getElementById('main-content');
    if (document.hidden) {
      mainContent.classList.add('blurred');
    } else {
      mainContent.classList.remove('blurred');
    }
  });
  
  let blurTime = 0;
  window.addEventListener('blur', function() {
    blurTime = Date.now();
    document.getElementById('main-content').classList.add('blurred');
  });
  
  window.addEventListener('focus', function() {
    const timeBlurred = Date.now() - blurTime;
    document.getElementById('main-content').classList.remove('blurred');
    if (timeBlurred > 0 && timeBlurred < 2000) {
      showScreenshotWarning();
    }
  });
  
  document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    return false;
  });
})();

const sendSound = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBDGD0fPTgjMGHm7A7+OZUQ0PVanm77BdGAg+ltryxmwnBjKB0PLSgDIFHmzA7+ObUQ4OV6zl776dUxILTqXh8bpsJAUuhND01oU0Bxtru+7mnlQODk+m4/C5Yh0FO5DX8sx6KwYohsvy1403CBlmu+3mnlQODU2k4fG6bCQGLoTR9NaEMwcZbbrv5J5UDg1NpOLwuWkcBTiP1/PNeCsGJ4TO8daCNggZZrvs5Z5UDg1MpOHxumwkBi6E0PTWhDMHGWy67+SeVA4NTKTi8LlpHAU4jtfzzXgrBieEzvLWgjYIGGa77eWeVBANTKPi8bpsIwYuhND01oQzBxlruu/knlQODUyk4vC5aRwGOI7X8814KwYnhM7y1oI2CBhmu+zlnlQQDUuj4vG6bCMGLoTQ9NaEMwcZa7rv5J5UDg1MpOLwuWkcBjiO1/PNeCsGJ4TO8taENggYZLrt5J9UEA1Lo+LxumwjBi6E0PTWhDMHGWu67+SeVA4NTKTi8LlpHAU4jtfzzXgrBieEzvLWgjYIGGS67eSfVBANS6Pi8bpsIwYuhND01YQzBxlruu/knlQODUyk4vC5aRwFOI7X8814KwYnhM7y1oI2CBhkuu3kn1QQDUuj4vG6bCMGLoTQ9NWEMwcZa7rv5J5UDg1MpOLwuGkcBTiO1/PNeCsGJ4PO8taCNggYZLrt5J9UEA1Lo+Lxumw');

function generateId(prefix = 'id') {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

function playSendSound() {
  try {
    sendSound.currentTime = 0;
    sendSound.play().catch(err => console.log('Sound play failed:', err));
  } catch (err) {
    console.log('Sound error:', err);
  }
}

// IMPROVED: Better image compression with chunking support
async function compressImage(file, maxSizeMB = 0.5) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = function(e) {
      const img = new Image();
      
      img.onload = function() {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;
        
        // Reduce max dimension for better compression
        const maxDimension = 800;
        if (width > height && width > maxDimension) {
          height = (height / width) * maxDimension;
          width = maxDimension;
        } else if (height > maxDimension) {
          width = (width / height) * maxDimension;
          height = maxDimension;
        }
        
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        // Start with lower quality for better compression
        let quality = 0.6;
        let compressedData = canvas.toDataURL('image/jpeg', quality);
        
        let estimatedSizeMB = (compressedData.length * 0.75) / (1024 * 1024);
        
        while (estimatedSizeMB > maxSizeMB && quality > 0.1) {
          quality -= 0.1;
          compressedData = canvas.toDataURL('image/jpeg', quality);
          estimatedSizeMB = (compressedData.length * 0.75) / (1024 * 1024);
        }
        
        debugLog(`Image compressed: ${(estimatedSizeMB * 1024).toFixed(2)}KB, quality: ${(quality * 100).toFixed(0)}%`);
        resolve(compressedData);
      };
      
      img.onerror = reject;
      img.src = e.target.result;
    };
    
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// IMPROVED: Chunked data transfer for large messages
function sendDataInChunks(data, type, additionalData = {}) {
  const dataStr = typeof data === 'string' ? data : JSON.stringify(data);
  const totalSize = dataStr.length;
  const chunkSize = state.chunkSize;
  const totalChunks = Math.ceil(totalSize / chunkSize);
  const transferId = generateId('transfer');
  
  debugLog(`Sending ${type} in ${totalChunks} chunks (${(totalSize / 1024).toFixed(2)}KB)`);
  
  for (let i = 0; i < totalChunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, totalSize);
    const chunk = dataStr.substring(start, end);
    
    const chunkData = {
      type: 'chunk',
      transferId: transferId,
      chunkIndex: i,
      totalChunks: totalChunks,
      chunk: chunk,
      dataType: type,
      ...additionalData
    };
    
    try {
      state.connection.send(chunkData);
    } catch (err) {
      debugLog(`Failed to send chunk ${i}/${totalChunks}: ${err.message}`);
      addSystemMessage('Failed to send data. Please try again.');
      return false;
    }
  }
  
  return true;
}

// IMPROVED: Receive and reassemble chunks
function handleChunk(chunkData) {
  const { transferId, chunkIndex, totalChunks, chunk, dataType } = chunkData;
  
  if (!state.pendingChunks.has(transferId)) {
    state.pendingChunks.set(transferId, {
      chunks: new Array(totalChunks),
      received: 0,
      dataType: dataType,
      metadata: chunkData
    });
  }
  
  const transfer = state.pendingChunks.get(transferId);
  transfer.chunks[chunkIndex] = chunk;
  transfer.received++;
  
  debugLog(`Received chunk ${chunkIndex + 1}/${totalChunks} for ${dataType}`);
  
  if (transfer.received === totalChunks) {
    const fullData = transfer.chunks.join('');
    state.pendingChunks.delete(transferId);
    
    debugLog(`‚úÖ Transfer complete: ${dataType} (${(fullData.length / 1024).toFixed(2)}KB)`);
    
    // Process the complete data
    if (dataType === 'image') {
      displayImage(transfer.metadata.username, fullData, transfer.metadata.profileEmoji || 'üë§', false);
      playSendSound();
      addSystemMessage('Image received! üì∑');
    } else if (dataType === 'message') {
      const messageData = JSON.parse(fullData);
      displayMessage(messageData.username, messageData.text, messageData.profileEmoji || 'üë§', false);
      playSendSound();
    }
  }
}

// Call functions
async function startAudioCall() {
  if (!state.isConnected) {
    alert('Not connected! Wait for your friend to join.');
    return;
  }
  
  if (state.inCall) {
    alert('Already in a call!');
    return;
  }
  
  try {
    state.localStream = await navigator.mediaDevices.getUserMedia({
      audio: true,
      video: false
    });
    
    state.callType = 'audio';
    initiateCall();
  } catch (err) {
    console.error('Error accessing microphone:', err);
    alert('Could not access microphone. Please check permissions.');
  }
}

async function startVideoCall() {
  if (!state.isConnected) {
    alert('Not connected! Wait for your friend to join.');
    return;
  }
  
  if (state.inCall) {
    alert('Already in a call!');
    return;
  }
  
  try {
    state.localStream = await navigator.mediaDevices.getUserMedia({
      audio: true,
      video: {
        width: { ideal: 1280 },
        height: { ideal: 720 }
      }
    });
    
    state.callType = 'video';
    initiateCall();
  } catch (err) {
    console.error('Error accessing camera/microphone:', err);
    alert('Could not access camera/microphone. Please check permissions.');
  }
}

function initiateCall() {
  state.connection.send({
    type: 'call-request',
    callType: state.callType,
    username: state.username
  });
  
  state.currentCall = state.peer.call(state.connection.peer, state.localStream);
  
  setupCallHandlers();
  showCallUI();
  addSystemMessage(`Calling... (${state.callType})`);
}

function setupCallHandlers() {
  if (!state.currentCall) return;
  
  state.currentCall.on('stream', (remoteStream) => {
    debugLog('‚úÖ Received remote stream');
    state.remoteStream = remoteStream;
    
    const remoteVideo = document.getElementById('remote-video');
    remoteVideo.srcObject = remoteStream;
    
    state.inCall = true;
    state.callStartTime = Date.now();
    startCallTimer();
    
    document.getElementById('call-status').textContent = `${state.callType === 'video' ? 'üìπ' : 'üìû'} Connected`;
    addSystemMessage(`${state.callType === 'video' ? 'Video' : 'Audio'} call connected!`);
  });
  
  state.currentCall.on('close', () => {
    debugLog('Call closed');
    endCall();
  });
  
  state.currentCall.on('error', (err) => {
    console.error('Call error:', err);
    addSystemMessage('Call error occurred');
    endCall();
  });
}

function showCallUI() {
  const videoContainer = document.getElementById('video-container');
  const localVideo = document.getElementById('local-video');
  const callControls = document.getElementById('call-controls');
  const endCallBtn = document.getElementById('end-call-btn');
  
  videoContainer.classList.add('active');
  callControls.classList.add('hidden');
  endCallBtn.classList.remove('hidden');
  
  if (state.localStream) {
    localVideo.srcObject = state.localStream;
    
    if (state.callType === 'audio') {
      localVideo.style.display = 'none';
      document.getElementById('remote-video').style.display = 'none';
    } else {
      localVideo.style.display = 'block';
      document.getElementById('remote-video').style.display = 'block';
    }
  }
}

function hideCallUI() {
  const videoContainer = document.getElementById('video-container');
  const callControls = document.getElementById('call-controls');
  const endCallBtn = document.getElementById('end-call-btn');
  
  videoContainer.classList.remove('active');
  callControls.classList.remove('hidden');
  endCallBtn.classList.add('hidden');
}

function startCallTimer() {
  stopCallTimer();
  
  state.callTimerInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - state.callStartTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    
    document.getElementById('call-timer').textContent = 
      `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }, 1000);
}

function stopCallTimer() {
  if (state.callTimerInterval) {
    clearInterval(state.callTimerInterval);
    state.callTimerInterval = null;
  }
}

function endCall() {
  if (state.localStream) {
    state.localStream.getTracks().forEach(track => track.stop());
    state.localStream = null;
  }
  
  if (state.currentCall) {
    state.currentCall.close();
    state.currentCall = null;
  }
  
  const localVideo = document.getElementById('local-video');
  const remoteVideo = document.getElementById('remote-video');
  localVideo.srcObject = null;
  remoteVideo.srcObject = null;
  
  state.inCall = false;
  state.callType = null;
  state.remoteStream = null;
  state.callStartTime = null;
  
  stopCallTimer();
  hideCallUI();
  
  if (state.connection && state.isConnected) {
    try {
      state.connection.send({
        type: 'call-ended'
      });
    } catch (err) {
      console.error('Error sending call-ended:', err);
    }
  }
  
  addSystemMessage('Call ended');
}

function showIncomingCallModal(callType, callerName) {
  const modal = document.getElementById('incoming-call-modal');
  const typeText = document.getElementById('incoming-call-type');
  const nameText = document.getElementById('incoming-caller-name');
  
  typeText.textContent = callType === 'video' ? 'üìπ Incoming Video Call' : 'üìû Incoming Audio Call';
  nameText.textContent = `${callerName} is calling...`;
  
  modal.classList.add('show');
}

function hideIncomingCallModal() {
  document.getElementById('incoming-call-modal').classList.remove('show');
}

async function acceptIncomingCall() {
  hideIncomingCallModal();
  
  if (!state.incomingCall) return;
  
  try {
    const constraints = state.callType === 'video' ? 
      { audio: true, video: { width: { ideal: 1280 }, height: { ideal: 720 } } } :
      { audio: true, video: false };
    
    state.localStream = await navigator.mediaDevices.getUserMedia(constraints);
    
    state.currentCall = state.incomingCall;
    state.currentCall.answer(state.localStream);
    
    setupCallHandlers();
    showCallUI();
    
    addSystemMessage(`${state.callType === 'video' ? 'Video' : 'Audio'} call accepted`);
    
  } catch (err) {
    console.error('Error accepting call:', err);
    alert('Could not access camera/microphone. Please check permissions.');
    rejectIncomingCall();
  }
  
  state.incomingCall = null;
}

function rejectIncomingCall() {
  hideIncomingCallModal();
  
  if (state.incomingCall) {
    state.incomingCall.close();
    state.incomingCall = null;
  }
  
  if (state.connection) {
    state.connection.send({
      type: 'call-rejected'
    });
  }
  
  addSystemMessage('Call rejected');
}

function initializeChat() {
  const username = document.getElementById('username-input').value.trim();
  
  if (!username) {
    alert('Please enter your name');
    return;
  }
  
  if (username.length < 2) {
    alert('Name must be at least 2 characters');
    return;
  }
  
  state.username = username;
  state.profileEmoji = selectedProfileEmoji;
  
  document.getElementById('profile-screen').classList.add('hidden');
  
  const urlParams = new URLSearchParams(window.location.search);
  const roomParam = urlParams.get('room');
  
  if (roomParam) {
    document.getElementById('chat-screen').classList.remove('hidden');
    joinRoom(roomParam);
  } else {
    document.getElementById('link-screen').classList.remove('hidden');
    
    document.getElementById('link-page-emoji').textContent = selectedProfileEmoji;
    document.getElementById('link-page-name').textContent = username;
    
    createRoom();
  }
}

// IMPROVED: Better peer creation with timeout handling
function createPeerInstance(peerId, config) {
  return new Promise((resolve, reject) => {
    const peer = new Peer(peerId, {
      debug: 2,
      config: config,
      // Add path and port for better reliability
      path: '/',
      secure: true
    });
    
    const timeout = setTimeout(() => {
      reject(new Error('Peer creation timeout after 30s'));
    }, 30000);
    
    peer.on('open', (id) => {
      clearTimeout(timeout);
      debugLog('‚úÖ Peer opened with ID: ' + id);
      resolve({ peer, id });
    });
    
    peer.on('error', (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });
}

function createRoom() {
  state.isHost = true;
  state.roomId = generateId('room');
  
  debugLog('üè† Creating room: ' + state.roomId);
  
  const newUrl = `${window.location.origin}${window.location.pathname}?room=${state.roomId}`;
  window.history.replaceState({}, '', newUrl);
  
  document.getElementById('room-link').textContent = newUrl;
  
  updateStatusLink('Creating room...', 'connecting');
  
  state.peerOpenPromise = createPeerInstance(state.roomId, iceConfig)
    .then(({ peer, id }) => {
      state.peer = peer;
      debugLog('‚úÖ Room created successfully: ' + id);
      state.peerReady = true;
      state.reconnectAttempts = 0;
      updateStatusLink('Room ready! Share the link üíó', 'connected');
      
      setupPeerEventHandlers();
    })
    .catch(err => {
      debugLog('‚ùå Failed to create room: ' + err.message);
      handlePeerError(err);
    });
}

function joinRoom(roomId) {
  state.isHost = false;
  state.roomId = roomId;
  state.myPeerId = generateId('guest');
  
  debugLog('üö™ Joining room: ' + roomId);
  
  updateStatus('Connecting to room...', 'connecting');
  addSystemMessage('Connecting to room...');
  
  state.peerOpenPromise = createPeerInstance(state.myPeerId, iceConfig)
    .then(({ peer, id }) => {
      state.peer = peer;
      debugLog('‚úÖ Peer ready: ' + id);
      state.peerReady = true;
      state.reconnectAttempts = 0;
      addSystemMessage('Connecting to your friend...');
      
      setupPeerEventHandlers();
      
      setTimeout(() => {
        attemptConnection();
      }, 2000);
    })
    .catch(err => {
      debugLog('‚ùå Failed to initialize peer: ' + err.message);
      handlePeerError(err);
    });
}

function setupPeerEventHandlers() {
  if (!state.peer) return;
  
  state.peer.on('connection', (conn) => {
    debugLog('üì• Incoming connection from: ' + conn.peer);
    
    if (state.linkExpired) {
      conn.on('open', () => {
        conn.send({ type: 'system', message: 'This room link has expired ‚ùå' });
        setTimeout(() => conn.close(), 100);
      });
      return;
    }
    
    if (state.isConnected && state.connection) {
      conn.on('open', () => {
        conn.send({ type: 'system', message: 'This room already has 2 people ‚ùå' });
        setTimeout(() => conn.close(), 100);
      });
      return;
    }
    
    handleConnection(conn);
  });
  
  state.peer.on('call', (call) => {
    debugLog('üìû Incoming call');
    state.incomingCall = call;
  });
  
  state.peer.on('disconnected', () => {
    debugLog('‚ö†Ô∏è Peer disconnected');
    state.peerReady = false;
    
    if (state.reconnectAttempts < state.maxReconnectAttempts && !state.peer.destroyed) {
      updateStatus(`Reconnecting... (${state.reconnectAttempts + 1}/${state.maxReconnectAttempts})`, 'connecting');
      state.reconnectAttempts++;
      
      setTimeout(() => {
        if (state.peer && !state.peer.destroyed) {
          debugLog('üîÑ Attempting to reconnect...');
          state.peer.reconnect();
        }
      }, 2000);
    } else {
      updateStatus('Connection lost. Please refresh the page.', 'error');
      addSystemMessage('Connection lost. Please refresh the page to reconnect.');
    }
  });

  state.peer.on('close', () => {
    debugLog('üîí Peer closed');
    state.peerReady = false;
  });
  
  state.peer.on('error', (err) => {
    debugLog('‚ùå Peer error: ' + err.type);
    handlePeerError(err);
  });
}

function attemptConnection() {
  if (state.connectionAttempts >= state.maxConnectionAttempts) {
    updateStatus('Failed to connect. Room may not exist.', 'error');
    addSystemMessage('Could not connect to room. The link may be invalid or expired.');
    return;
  }
  
  if (!state.peerReady || !state.peer) {
    debugLog('‚ö†Ô∏è Peer not ready yet, waiting...');
    setTimeout(() => attemptConnection(), 1000);
    return;
  }
  
  state.connectionAttempts++;
  debugLog(`üîå Connection attempt ${state.connectionAttempts}/${state.maxConnectionAttempts}`);
  
  updateStatus(`Connecting... (${state.connectionAttempts}/${state.maxConnectionAttempts})`, 'connecting');
  
  try {
    const conn = state.peer.connect(state.roomId, { 
      reliable: true,
      serialization: 'json',
      metadata: {
        username: state.username,
        profileEmoji: state.profileEmoji
      }
    });
    
    if (!conn) {
      debugLog('‚ùå Failed to create connection object');
      retryConnection();
      return;
    }
    
    handleConnection(conn);
    
    clearTimeout(state.connectionTimeout);
    state.connectionTimeout = setTimeout(() => {
      if (!state.isConnected) {
        debugLog('‚è±Ô∏è Connection timeout');
        retryConnection();
      }
    }, 15000);
    
  } catch (err) {
    debugLog('‚ùå Connection error: ' + err.message);
    retryConnection();
  }
}

function retryConnection() {
  if (state.connection && !state.isConnected) {
    state.connection.close();
    state.connection = null;
  }
  
  if (state.connectionAttempts < state.maxConnectionAttempts) {
    addSystemMessage(`Retrying connection... (${state.connectionAttempts}/${state.maxConnectionAttempts})`);
    setTimeout(() => {
      attemptConnection();
    }, 3000);
  } else {
    updateStatus('Connection failed', 'error');
    addSystemMessage('Could not connect to room. Please check the link and try again.');
  }
}

function handleConnection(conn) {
  debugLog('üîó Setting up connection with: ' + conn.peer);
  state.connection = conn;
  
  conn.on('open', () => {
    clearTimeout(state.connectionTimeout);
    debugLog('‚úÖ Connection established!');
    state.isConnected = true;
    state.dataChannelReady = true;
    state.reconnectAttempts = 0;
    state.connectionAttempts = 0;
    
    if (state.isHost && !document.getElementById('chat-screen').classList.contains('hidden') === false) {
      document.getElementById('link-screen').classList.add('hidden');
      document.getElementById('chat-screen').classList.remove('hidden');
    }
    
    updateStatus('Connected! Start chatting üíó', 'connected');
    addSystemMessage('Connected! You can now chat üíó');
    
    try {
      conn.send({
        type: 'handshake',
        username: state.username,
        profileEmoji: state.profileEmoji,
        timestamp: Date.now()
      });
      debugLog('üì§ Handshake sent');
    } catch (err) {
      debugLog('‚ùå Failed to send handshake: ' + err.message);
    }
  });
  
  conn.on('data', (data) => {
    debugLog('üì® Received: ' + (data?.type || 'unknown'));
    handleReceivedData(data);
  });
  
  conn.on('close', () => {
    debugLog('üîå Connection closed');
    state.isConnected = false;
    state.dataChannelReady = false;
    updateStatus('Friend disconnected ‚ùå', 'error');
    addSystemMessage('Your friend disconnected ‚ùå');
    state.connection = null;
    
    if (state.inCall) {
      endCall();
    }
  });
  
  conn.on('error', (err) => {
    debugLog('‚ùå Connection error: ' + err.message);
    if (state.isConnected) {
      addSystemMessage('Connection error occurred');
    } else {
      retryConnection();
    }
  });
  
  conn.peerConnection.addEventListener('iceconnectionstatechange', () => {
    const iceState = conn.peerConnection.iceConnectionState;
    debugLog('üßä ICE state: ' + iceState);
    
    if (iceState === 'connected' || iceState === 'completed') {
      debugLog('‚úÖ ICE connection established');
      state.dataChannelReady = true;
    } else if (iceState === 'failed' || iceState === 'disconnected') {
      debugLog('‚ö†Ô∏è ICE connection issues detected');
      state.dataChannelReady = false;
      if (!state.isConnected) {
        retryConnection();
      }
    }
  });
}

function handleReceivedData(data) {
  if (!data || typeof data !== 'object') {
    debugLog('‚ö†Ô∏è Invalid data received');
    return;
  }
  
  try {
    switch (data.type) {
      case 'handshake':
        debugLog('ü§ù Handshake from: ' + data.username);
        state.friendProfileEmoji = data.profileEmoji || 'üë§';
        addSystemMessage(`${data.username} joined the chat!`);
        break;
        
      case 'chunk':
        handleChunk(data);
        break;
        
      case 'message':
        if (data.text) {
          displayMessage(data.username, data.text, data.profileEmoji || 'üë§', false);
          playSendSound();
        }
        break;
        
      case 'image':
        if (data.imageData) {
          displayImage(data.username, data.imageData, data.profileEmoji || 'üë§', false);
          playSendSound();
        }
        break;
        
      case 'call-request':
        state.callType = data.callType;
        showIncomingCallModal(data.callType, data.username);
        break;
        
      case 'call-rejected':
        addSystemMessage('Call was rejected');
        endCall();
        break;
        
      case 'call-ended':
        addSystemMessage('Call ended by friend');
        endCall();
        break;
        
      case 'system':
        if (data.message) {
          addSystemMessage(data.message);
        }
        break;
        
      default:
        debugLog('‚ö†Ô∏è Unknown message type: ' + data.type);
    }
  } catch (err) {
    debugLog('‚ùå Error handling data: ' + err.message);
  }
}

function sendMessage() {
  if (!state.isConnected || !state.connection) {
    alert('Not connected! Wait for your friend to join.');
    return;
  }
  
  const input = document.getElementById('message-input');
  const text = input.value.trim();
  
  if (!text) return;
  
  try {
    // For text messages, send directly if small enough
    if (text.length < 1000) {
      state.connection.send({
        type: 'message',
        username: state.username,
        profileEmoji: state.profileEmoji,
        text: text,
        timestamp: Date.now()
      });
    } else {
      // Use chunking for very long messages
      sendDataInChunks(
        { username: state.username, text: text, profileEmoji: state.profileEmoji },
        'message',
        { username: state.username, profileEmoji: state.profileEmoji }
      );
    }
    
    displayMessage(state.username, text, state.profileEmoji, true);
    playSendSound();
    
    input.value = '';
    input.focus();
  } catch (err) {
    debugLog('‚ùå Failed to send message: ' + err.message);
    addSystemMessage('Failed to send message');
  }
}

// IMPROVED: Better image selection and sending
function selectImage() {
  if (!state.isConnected || !state.connection) {
    alert('Not connected! Wait for your friend to join.');
    return;
  }
  
  if (!state.dataChannelReady) {
    alert('Connection not fully established. Please wait a moment.');
    return;
  }
  
  document.getElementById('file-input').click();
}

async function sendImage(file) {
  if (!file) return;
  
  if (!state.isConnected || !state.connection) {
    alert('Not connected! Wait for your friend to join.');
    return;
  }
  
  if (!file.type.startsWith('image/')) {
    alert('Please select an image file.');
    return;
  }
  
  addSystemMessage('Compressing image...');
  
  try {
    const compressedImage = await compressImage(file, 0.5);
    const imageSize = (compressedImage.length * 0.75) / (1024 * 1024);
    
    debugLog(`Sending image: ${(imageSize * 1024).toFixed(2)}KB`);
    addSystemMessage(`Sending image (${(imageSize * 1024).toFixed(2)}KB)...`);
    
    // Use chunking for reliability
    const success = sendDataInChunks(
      compressedImage,
      'image',
      {
        username: state.username,
        profileEmoji: state.profileEmoji
      }
    );
    
    if (success) {
      displayImage(state.username, compressedImage, state.profileEmoji, true);
      playSendSound();
      addSystemMessage('Image sent! üì∑');
    }
    
  } catch (err) {
    console.error('Failed to send image:', err);
    addSystemMessage('Failed to send image. Try a smaller image.');
    debugLog('‚ùå Image send error: ' + err.message);
  }
}

function displayMessage(username, text, emoji, isSent) {
  const messagesDiv = document.getElementById('messages');
  
  const wrapper = document.createElement('div');
  wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
  
  const emojiCircle = document.createElement('div');
  emojiCircle.className = 'profile-emoji-circle';
  emojiCircle.textContent = emoji;
  
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
  
  const usernameDiv = document.createElement('div');
  usernameDiv.className = 'username';
  usernameDiv.textContent = username;
  
  const textDiv = document.createElement('div');
  textDiv.className = 'text';
  textDiv.textContent = text;
  
  messageDiv.appendChild(usernameDiv);
  messageDiv.appendChild(textDiv);
  
  wrapper.appendChild(emojiCircle);
  wrapper.appendChild(messageDiv);
  
  messagesDiv.appendChild(wrapper);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function displayImage(username, imageData, emoji, isSent) {
  const messagesDiv = document.getElementById('messages');
  
  const wrapper = document.createElement('div');
  wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
  
  const emojiCircle = document.createElement('div');
  emojiCircle.className = 'profile-emoji-circle';
  emojiCircle.textContent = emoji;
  
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
  
  const usernameDiv = document.createElement('div');
  usernameDiv.className = 'username';
  usernameDiv.textContent = username;
  
  const img = document.createElement('img');
  img.src = imageData;
  img.alt = 'Shared image';
  img.onclick = function() {
    openImageModal(imageData);
  };
  
  messageDiv.appendChild(usernameDiv);
  messageDiv.appendChild(img);
  
  wrapper.appendChild(emojiCircle);
  wrapper.appendChild(messageDiv);
  
  messagesDiv.appendChild(wrapper);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function openImageModal(imageSrc) {
  const modal = document.getElementById('image-modal');
  const modalImg = document.getElementById('modal-image');
  modal.classList.add('show');
  modalImg.src = imageSrc;
}

function closeImageModal() {
  const modal = document.getElementById('image-modal');
  modal.classList.remove('show');
}

function addSystemMessage(text) {
  const messagesDiv = document.getElementById('messages');
  
  const messageDiv = document.createElement('div');
  messageDiv.className = 'system-message';
  messageDiv.textContent = `‚Ä¢ ${text}`;
  
  messagesDiv.appendChild(messageDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function updateStatus(text, type) {
  const statusDiv = document.getElementById('status');
  statusDiv.textContent = text;
  statusDiv.className = type;
}

function updateStatusLink(text, type) {
  const statusDiv = document.getElementById('status-link');
  statusDiv.textContent = text;
  statusDiv.className = type;
}

function handlePeerError(err) {
  debugLog('üö® Peer error type: ' + (err.type || 'unknown'));
  
  const errorType = err.type || err.message || 'unknown';
  
  switch (errorType) {
    case 'peer-unavailable':
      updateStatus('Room not found ‚ùå', 'error');
      addSystemMessage('Could not find room. The link may be invalid or expired.');
      
      if (!state.isHost && state.connectionAttempts < state.maxConnectionAttempts) {
        setTimeout(() => {
          addSystemMessage('Retrying...');
          attemptConnection();
        }, 3000);
      }
      break;
      
    case 'network':
    case 'disconnected':
      updateStatus('Network error ‚ùå', 'error');
      addSystemMessage('Network connection failed. Check your internet connection.');
      
      if (state.reconnectAttempts < state.maxReconnectAttempts) {
        setTimeout(() => {
          if (state.peer && !state.peer.destroyed) {
            state.peer.reconnect();
          }
        }, 3000);
      }
      break;
      
    case 'server-error':
      updateStatus('Server error ‚ùå', 'error');
      addSystemMessage('PeerJS server error. Please try again in a moment.');
      break;
      
    case 'socket-error':
    case 'socket-closed':
      updateStatus('Connection error ‚ùå', 'error');
      addSystemMessage('Socket error. Attempting to reconnect...');
      
      if (state.reconnectAttempts < state.maxReconnectAttempts) {
        setTimeout(() => {
          if (state.peer && !state.peer.destroyed) {
            state.peer.reconnect();
          }
        }, 2000);
      }
      break;
      
    case 'unavailable-id':
      updateStatus('ID conflict ‚ùå', 'error');
      addSystemMessage('Room ID conflict. Please refresh and create a new room.');
      break;
      
    case 'ssl-unavailable':
      updateStatus('SSL error ‚ùå', 'error');
      addSystemMessage('Secure connection unavailable. Try using HTTPS.');
      break;
      
    default:
      updateStatus('Connection error ‚ùå', 'error');
      addSystemMessage(`Error: ${errorType}. Please refresh the page.`);
  }
}

function copyRoomLink() {
  const roomLink = document.getElementById('room-link').textContent;
  
  navigator.clipboard.writeText(roomLink).then(() => {
    alert('‚úÖ Link copied to clipboard! Share it with your friend.');
    
    if (!state.linkCopied) {
      state.linkCopied = true;
      startExpiryTimer();
    }
  }).catch((err) => {
    console.error('Copy failed:', err);
    
    const textArea = document.createElement('textarea');
    textArea.value = roomLink;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      document.execCommand('copy');
      alert('‚úÖ Link copied! Share it with your friend.');
      if (!state.linkCopied) {
        state.linkCopied = true;
        startExpiryTimer();
      }
    } catch (err) {
      alert('Failed to copy. Please copy the link manually.');
    }
    
    document.body.removeChild(textArea);
  });
}

function startExpiryTimer() {
  let timeLeft = 1200;
  const timerDiv = document.getElementById('timer');
  
  function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }
  
  timerDiv.textContent = `‚è∞ Link expires in: ${formatTime(timeLeft)}`;
  
  state.timerInterval = setInterval(() => {
    timeLeft--;
    
    if (timeLeft <= 0) {
      clearInterval(state.timerInterval);
      state.linkExpired = true;
      timerDiv.textContent = '‚ö†Ô∏è Link expired';
    } else {
      timerDiv.textContent = `‚è∞ Link expires in: ${formatTime(timeLeft)}`;
    }
  }, 1000);
}

function insertEmoji(emoji) {
  const input = document.getElementById('message-input');
  input.value += emoji;
  input.focus();
}

document.addEventListener('DOMContentLoaded', () => {
  const messageInput = document.getElementById('message-input');
  const usernameInput = document.getElementById('username-input');
  const fileInput = document.getElementById('file-input');
  
  if (usernameInput) {
    usernameInput.addEventListener('input', (e) => {
      const name = e.target.value.trim() || 'Your name';
      document.getElementById('preview-name').textContent = name;
    });
  }
  
  if (messageInput) {
    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
  }
  
  if (usernameInput) {
    usernameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        initializeChat();
      }
    });
    usernameInput.focus();
  }
  
  if (fileInput) {
    fileInput.addEventListener('change', async function(e) {
      const file = e.target.files[0];
      if (file) {
        await sendImage(file);
      }
      e.target.value = '';
    });
  }
});

window.addEventListener('beforeunload', () => {
  if (state.inCall) {
    endCall();
  }
  
  if (state.connection) {
    try {
      state.connection.close();
    } catch (err) {
      console.error('Error closing connection:', err);
    }
  }
  if (state.peer) {
    try {
      state.peer.destroy();
    } catch (err) {
      console.error('Error destroying peer:', err);
    }
  }
  if (state.timerInterval) {
    clearInterval(state.timerInterval);
  }
});

debugLog('üöÄ US CONVO Fixed Version Loaded');
</script>
</body>
</html>